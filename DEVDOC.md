Файл содержит информацию, полезную разработчикам новых унифицированных блоков.

# Качество кода

1. Что не имеет собственного имени - не существует.

   При декомпозиции следует избегать слишком общих или дублирующих имён. Каждая выносимая сущность должна определяться по смыслу и получать соответствующее название. Не по принадлежности к категории или другой сущности, а по сути самой выносимой сущности.

2. Нейминг файлов проекта.

При наименовании файлов в проекте не следует использовать название index.ts, поскольку при сборке данные файлы будут проигнорированы.
Только корневой файл проекта может иметь наименование index.ts

При именовании иконок, расположенных в директории `./src/icons`, необходимо придерживаться конвенции:

- наименование файла должно оторажать сущность иконки;
- наименование файла должно оканчиваться на Icon, наприме, CardIcon.svg;
- файл иконки должен содержать title - добавляется разработчиком при создании нового файла, описание должно быть на русском языке.
- если иконка подразумевает возможность перекрашиваться через iconVersion. Необходимо отредактировать svg файл. Цвет который может изменяться указать как currentColor, остальные цвета заменить на #000000, так же требуется рядом с атрибутом title указать атрибут isInverse="true"

```
<svg title="Деньги"></svg>
```

3. Следует избегать вложенных тернарников.

   Вложенные условия можно выносить в константы или отдельные функции. В отдельных случаях можно прибегать к предусловиям для "разгрузки" первых уровней вложенности. Для оформления предусловий часто приходится прибегать к логической инверсии. Тогда полезная следующая теорема:

   ```
   !(A | B) = !A & !B
   !(A & B) = !A | !B
   ```

4. Позитивные условия сначала.

   Bad

   ```tsx
   role={!href ? 'button' : 'link'}
   ```

   Good

   ```tsx
   role={href ? 'link' : 'button'}
   ```

5. Типы контента компонентов должны быть всегда опциональными.

Bad

```ts
interface AccordionItemCommonProps {
  label: string;
  blocks: AccordionBlockProps[];
  bordered: boolean;
}
```

Good

```ts
interface AccordionItemCommonProps {
  label?: string;
  blocks?: AccordionBlockProps[];
  bordered?: boolean;
}
```

6. Следует избегать прямых импортов.

Bad

```ts
import { Component } from './Component.mobile';
```

Good

```ts
import { Component } from './Component';
```

7. Строки со сложной интерполяцией через массив с последующим `join(' ')`.

   Bad

   ```ts
   const style = `flex items-center justify-center
     ${withoutText ? 'h-12 w-12' : `px-8 gap-2 ${aboveText ? 'py-2' : 'py-3.5'}`} ${
     rounded ? 'rounded-full' : ''
   }`;
   ```

   Good

   ```ts
   const style = [
     'flex items-center justify-center',
     isWithText(props) ? withTextStyle : 'h-12 w-12',
     rounded ? 'rounded-full' : '',
   ].join(' ');
   ```

# Стили

## Размер common.css

### Использование классов

- Не использовать классы `space-...`, обходиться `margin` и `gap`
- Минимизировать использование `grid-cols-...`
- Минимизировать использование псевдоэлементов
- Минимизировать использование `transition`

### Унификация

Все

- отступы
- высоты
- ширины
- скругления
- ховеры
- границы
  элементов должны быть унифицированы, расхождения обсудить с дизайнерами

### Пересечение с зарезервированными именами

При сборке tailwind проверяет исходный код на наличие совпадений с зарезервированными именами атомов. Таким образом возможно пересечение с зарезервироваными словами JS (например filter - array.filter) или с именами переменных. В случае с filter, данный атом будет отключен через конфиг tailwind

Это необходимо учитывать при создании переменных.

# Чек-листы

## Привила декларации типов

- Вынести декларацию типа контента блока `<block_name>Content` в отдельный файл `<block_name>Content.ts` в соответствии с требованиями в тикете
- Файл, содержащий декларацию типа контента блока должен в обязательном порядке содержать слово Content, поскольку оно является ключевым при определении файлов с декларациями типов при сборке проекта
  Обязательным также является экспорт декларации типа контента блока `<block_name>Content` в файле BlockContent.ts
- Рекомендуется выносить составную декларацию типов в в отдельный файл `<block_name>Content.ts` и не прописывать ее непосредственно в файле `Component.tsx`

  Bad

  ```ts
  type ComparisonTableRowsProps = TableArrowScrollControlProps & {
    rowData: { header: HeadingContent; data: CellData[][] }[];
  };
  ```

  Good

  ```ts
  import type { CellData } from './ComparisonTableContent';

  export interface TableCellProps {
    cell: CellData[];
  }
  ```

### Добавление нового компонента и очередность отображения его полей в кабинете редактора относительно других полей

После добавления нового компонента в проект `uni-blocks` и корректного отображения очередности полей в кабинете редактора необходимо добавить это поле в файл `./scsripts/schema-sort-index.js`.

Данный файл содержит правило сортировки всех полей для кабинета редактора.
В случае, если новые поля не будут добвлены в указанный файл, в кабинете редактора данные поля будут отображены выше правил, описанных в файле `./scsripts/schema-sort-index.js`.

Пример: в кабинете редактора необходимо расположить поля `title` и `subtitle` выше, чем поле `bonusBenefits`.

Для этого, свойство `bonusBenefits` необходимо расположить ниже свойств `title` и `subtitle` в файле `./scsripts/schema-sort-index.js`.

```ts
export default [
  'title',
  'titleSize',
  'subtitle',
  'date',
  'columns',
  'align',
  'description',
  'bonusItems',
  'image',
  'backwardButton',
  'breadcrumbs',
  'benefits',
  'bonusBenefits',
];
```

## Cоздание и вёрстка блока

- PixelPerfect по дизайнам
  [Расширение для Chromium-браузеров](https://chrome.google.com/webstore/detail/perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi?hl=ru)
  [Как извлечь слой из Figma](https://www.captain-design.com/blog/how-to-export-images-in-figma/)
- Добавить fixture-файл рядом с кодом блока с именем `<block_name>.fixture.ts`
  Данное требование является обязательным для файлов, расположенных в директории ./src/components и опциональным для атомов, расположенных в директории ./src/ui-kit
  При этом, fixture-файл должен обязательно содержать экспорт дефолтной версии блока или атома и опционально иные имеющиеся версии.
- В случае, когда у атома отсутствует fixture-файл и/или content-файл, данный файл может быть расположен непосредственно в директори ./src/ui-kit. В ином случае для атома должна быть создана отдельная директоиия в ./src/ui-kit
- Проверка внешнего вида на всех согласованных расширениях (используем cosmos `npm run cosmos`)
- Проверка переходов между расширениями

Если всё в порядке:

- Добавить новый блок [сюда](./src/Blocks.ts)
- Добавить тип контента блока [сюда](./src/BlockContent.ts)
- Добавить новый блок в соответствии с его схемой [сюда](./src/ContentPage.page.json)
- Проверить, что интерфейс Content (то, что будет заполнять оператор) отделён от интерфейса прочих props
- Внести интерфейс Сontent в юнион тип [тут](./src/Blocks.ts)
- После прогнать тесты с помощью команды `npm run test` и сверить изменения
  Если всё ок - обновить снимок схемы с помощью команды `test:update`

### Создание fixture для Cosmos

При разработке fixture следует придерживаться правила: в одной fixture должен находиться один вариант блока. Это необходимо для повышения стабильности тестов по визуальному регрессу

### Частые проблемы при запуске проекта

- Одной из частых проблем при запуске проекта является отключение иконок. Для решения данной проблемы следует заново пересобрать проект в части иконок, используя команду `npm run build:icons`
- При внесении изменений в файл с типом контента блокам - ./src/BlockContent.ts следует обязательно запустить тесты в проекте. Это необходимо, во-первых, поскольку типы могут наследовать друг друга, что может привести к ошибкам и невалидной сборке проекта. Во-вторых, в случае внесения изменений в типизацию снимки схемы в тестах будут расходится, что приведет к падению джобы в пайплайне.
  Тест по снапшоту схемы поможет определить, поменялась ли эта схема. Поэтому если меняется структура контента, после билда схемы необходимо прогнать тесты с помощью команды - `npm run test`
  В случае, когда разработчик уверен в том, что он делает все правильно, можно сверить изменения и, если всё отвечает требованиям, обновить снимок схемы командой `test:update` снапшот, и тест будет проходить.
  Данные изменения должны быть обязательно добавлены и внесены разработчиком при оформлении коммита

### UI Schema блока

В директории с каждым блоком должен находиться файл именованный по паттерну `BlockName.ui.json`.

В этом файле можно задать виджеты к полям, а так же `ui:options`.

Пример с ограничением ширины блока

```json
{
  "content": {},
  "style": {
    "ui:options": {
      "minCols": 6,
      "maxCols": 10
    }
  }
}
```
