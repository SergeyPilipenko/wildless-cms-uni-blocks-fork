Файл содержит информацию, полезную разработчикам новых унифицированных блоков.

# Качество кода

1. Что не имеет собственного имени - не существует.

   При декомпозиции следует избегать слишком общих или дублирующих имён. Каждая выносимая сущность должна определяться по смыслу и получать соответствующее название. Не по принадлежности к категории или другой сущности, а по сути самой выносимой сущности.

2. Нейминг файлов проекта.

  При наименовании файлов в проекте не следует использовать название index.ts, поскольку при сборке данные файлы будут проигнорированы.
  Только корневой файл проекта может иметь наименование index.ts

3. Следует избегать вложенных тернарников.

   Вложенные условия можно выносить в константы или отдельные функции. В отдельных случаях можно прибегать к предусловиям для "разгрузки" первых уровней вложенности. Для оформления предусловий часто приходится прибегать к логической инверсии. Тогда полезная следующая теорема:

   ```
   !(A | B) = !A & !B
   !(A & B) = !A | !B
   ```

4. Позитивные условия сначала.

   Bad

   ```tsx
   role={!href ? 'button' : 'link'}
   ```

   Good

   ```tsx
   role={href ? 'link' : 'button'}
   ```

5. Типы контента компонентов должны быть всегда опциональными.

  Bad

  ```ts
  interface AccordionItemCommonProps {
    label: string;
    blocks: AccordionBlockProps[];
    bordered: boolean; 
  };
  ```

  Good

  ```ts
  interface AccordionItemCommonProps {
    label?: string;
    blocks?: AccordionBlockProps[];
    bordered?: boolean; 
  };
  ```

6. Следует избегать прямых импортов.

  Bad

  ```ts
    import { Component } from './Component.mobile';
  ```

  Good
  
  ```ts
    import { Component } from './Component';
  ```

7. Строки со сложной интерполяцией через массив с последующим `join(' ')`.

   Bad

   ```ts
   const style = `flex items-center justify-center
     ${withoutText ? 'h-12 w-12' : `px-8 gap-2 ${aboveText ? 'py-2' : 'py-3.5'}`} ${
     rounded ? 'rounded-full' : ''
   }`;
   ```

   Good

   ```ts
   const style = [
     'flex items-center justify-center',
     isWithText(props) ? withTextStyle : 'h-12 w-12',
     rounded ? 'rounded-full' : '',
   ].join(' ');
   ```

# Стили

## Размер common.css

### Использование классов

- Не использовать классы `space-...`, обходиться `margin` и `gap`
- Минимизировать использование `grid-cols-...`
- Минимизировать использование псевдоэлементов
- Минимизировать использование `transition`

### Унификация

Все

- отступы
- высоты
- ширины
- скругления
- ховеры
- границы
  элементов должны быть унифицированы, расхождения обсудить с дизайнерами

### Пересечение с зарезервированными именами

При сборке tailwind проверяет исходный код на наличие совпадений с зарезервированными именами атомов. Таким образом возможно пересечение с зарезервироваными словами JS (например filter - array.filter) или с именами переменных. В случае с filter, данный атом будет отключен через конфиг tailwind

Это необходимо учитывать при создании переменных.

# Чек-листы

## Привила декларации типов

- Вынести декларацию типа контента блока `<block_name>Content` в отдельный файл `<block_name>Content.ts` в соответствии с требованиями в тикете
- Файл, содержащий декларацию типа контента блока должен в обязательном порядке содержать слово Content, поскольку оно является ключевым при определении файлов с декларациями типов при сборке проекта
Обязательным также является экспорт декларации типа контента блока `<block_name>Content` в файле BlockContent.ts
- Рекомендуется выносить составную декларацию типов в в отдельный файл `<block_name>Content.ts` и не прописывать ее непосредственно в файле `Component.tsx`

  Bad

  ```ts
    type ComparisonTableRowsProps = TableArrowScrollControlProps & {
      rowData: { header: HeadingContent; data: CellData[][] }[];
    };
  ```

  Good

  ```ts
    import type { CellData } from './ComparisonTableContent';

    export interface TableCellProps {
      cell: CellData[];
    };
  ```

### Добавление нового компонента и очередность отображения его полей в кабинете редактора относительно других полей 

  После добавления нового компонента в проект `uni-blocks` и корректного отображения очередности полей в кабинете редактора необходимо добавить это поле в файл `./scsripts/schema-sort-index.js`. 
  
  Данный файл содержит правило сортировки всех полей для кабинета редактора.
  В случае, если новые поля не будут добвлены в указанный файл, в кабинете редактора данные поля будут отображены выше правил, описанных в файле `./scsripts/schema-sort-index.js`. 

  Пример: в кабинете редактора необходимо расположить поля `title` и `subtitle` выше, чем поле `bonusBenefits`.

  Для этого, свойство `bonusBenefits` необходимо расположить ниже свойств `title` и `subtitle` в файле `./scsripts/schema-sort-index.js`.

  ```ts
     export default [
      'title',
      'titleSize',
      'subtitle',
      'date',
      'columns',
      'align',
      'description',
      'bonusItems',
      'image',
      'backwardButton',
      'breadcrumbs',
      'benefits',
      'bonusBenefits',
    ]
  ```

## Cоздание и вёрстка блока

- PixelPerfect по дизайнам
  [Расширение для Chromium-браузеров](https://chrome.google.com/webstore/detail/perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi?hl=ru)
  [Как извлечь слой из Figma](https://www.captain-design.com/blog/how-to-export-images-in-figma/)
- Добавить fixture-файл рядом с кодом блока с именем `<block_name>.fixture.ts`
Данное требование является обязательным для файлов, расположенных в директории ./src/components и опциональным для атомов, расположенных в директории ./src/ui-kit
При этом, fixture-файл должен обязательно содержать экспорт дефолтной версии блока или атома и опционально иные имеющиеся версии.
- В случае, когда у атома отсутствует fixture-файл и/или content-файл, данный файл может быть расположен непосредственно в директори ./src/ui-kit. В ином случае для атома должна быть создана отдельная директоиия в ./src/ui-kit
- Проверка внешнего вида на всех согласованных расширениях (используем cosmos `npm run cosmos`)
- Проверка переходов между расширениями

Если всё в порядке:

- Добавить новый блок [сюда](./src/Blocks.ts)
- Добавить тип контента блока [сюда](./src/BlockContent.ts)
- Добавить новый блок в соответствии с его схемой [сюда](./src/ContentPage.page.json)
- Проверить, что интерфейс Content (то, что будет заполнять оператор) отделён от интерфейса прочих props
- Внести интерфейс Сontent в юнион тип [тут](./src/Blocks.ts)
- После прогнать тесты с помощью команды `npm run test` и сверить изменения
Если всё ок - обновить снимок схемы с помощью команды `npm run test -- -u`

### Частые проблемы при запуске проекта

  - Одной из частых проблем при запуске проекта является отключение иконок. Для решения данной проблемы следует заново пересобрать проект в части иконок, используя команду `npm run build:icons`
  - При внесении изменений в файл с типом контента блокам - ./src/BlockContent.ts следует обязательно запустить тесты в проекте. Это необходимо, во-первых, поскольку типы могут наследовать друг друга, что может привести к ошибкам и невалидной сборке проекта. Во-вторых, в случае внесения изменений в типизацию снимки схемы в тестах будут расходится, что приведет к падению джобы в пайплайне.
  Тест по снапшоту схемы поможет определить, поменялась ли эта схема. Поэтому если меняется структура контента, после билда схемы необходимо прогнать тесты с помощью команды - `npm run test`
  В случае, когда разработчик уверен в том, что он делает все правильно, можно сверить изменения и, если всё отвечает требованиям, обновить снимок схемы  командой `npm run test -- -u` снапшот, и тест будет проходить.
  Данные изменения должны быть обязательно добавлены и внесены разработчиком при оформлении коммита
